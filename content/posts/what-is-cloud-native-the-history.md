---
title:  What is cloud-native?! - The history
description: Everyone is talking about cloud-native infrastructure and applications and how containers and container orchestration tools are important to an application's cloud-native journey. But what is cloud-native? Is it some complex architecture that requires an army of people to develop and manage? Is it a light switch that magically transforms your legacy applications into cloud-native ones? Find the answer.
date:   2023-01-01
authors: [ravikanth]
image:  '/images/cloudnative.png'
tags:   [cloud-native, learning]
featured: true
draft: true
---

Cloud-native is not an alien term anymore. It is not an exaggeration to say that modern application architecture conversations cannot be complete without referencing cloud-native concepts and technologies. The industry evolved into where it is today. We started with physical servers in a room full of racks, moved to consolidate these physical servers to run virtual machines, realized cloud-computing promises to reduce costs while enabling us to run our applications at planet-scale, and entered the era of microservices-based architectures with containers and Kubernetes. What motivated this evolution? Let us dive in.

## A brief history 

I started my IT career right after my graduation in the year 2000. I started as a customer support engineer and a system administrator managing Windows, Solaris, and Novell NetWare servers. These physical servers had a single application per server. The Windows servers were running Microsoft Exchange and SQL Server applications. Solaris systems were used to run Enterprise Resource Planning (ERP) applications, and the NetWare servers were used for thin clients and as file servers. Whenever we had to perform maintenance on these physical servers, we had to bring the applications offline. Each of these servers was configured to support the peak user load, and as a reason, on most days, there was less than 30% resource utilization. Scaling an application to support peak load required adding more physical servers. Procuring new servers was not easy well. It took us months to receive the systems and a few more days to weeks to set them up for running applications.

It was not easy to run multiple applications on a physical server without running into application dependency conflicts, resulting in a lower return on investment (ROI). The management overhead was real. We had to patch the hardware, OS, and applications on these servers. We found some smart ways to combine these into a single maintenance window, only to realize that it was too long to finish over a weekend! Most of our developers used their workstations to develop the code deployed into production. The "works-on-my-system" syndrome caused a lot of rift between the development and IT operations teams. 

Around 2006, virtualization arrived and helped us consolidate these physical servers and increase the number of applications running per server. Instead of limiting ourselves to one OS per server, we could run multiple different operating systems per server, each in its virtual machine, which provided an emulated view of the physical server. This allowed us to run multiple applications per physical server. Virtualization helped increase the density of applications per server and increased overall utilization. However, the necessity to run a full-blown guest OS in the virtual machine resulted in a waste of resources. Like physical servers, virtual machines too, require patching the guest OS and application libraries. Virtual machine managers such as VMware vCenter and System Center Virtual Machine Manager (SCVMM) provided a way to templatize virtual machines and automate the creation of virtualized application services. Even with this kind of automation, scaling out an application for peak load was not seamless. The size of a virtual machine prevented this. The lack of standardization in virtual machine format limited the portability of virtual machines across different types of hypervisor infrastructure, resulting in vendor lock-in. Virtual machine templates helped application developers develop in an environment similar to the production environment.

Around the time virtualization became mainstream in enterprise data centers, a few companies were building web-scale applications. Companies like Google, Netflix, and Facebook built applications that supported millions of users. These applications were built to be resilient, highly available, and scalable. Such applications could not be just a bunch of physical servers or virtual machines. These applications needed the infrastructure to be elastically scalable. This meant new application service instances had to be started and stopped at a moment's notice. 

