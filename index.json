

    

    

    

    

[{"content":"Containers changed the way we develop, package, and distribute applications. This helped teams accelerate development and ensure their code worked consistently across different environments and infrastructures. To a large extent, this enabled write once and run anywhere. Docker made this easy by providing tools to create, manage, and package application code and dependencies as images. We could run a container instance from that image wherever a container runtime exists. Standardizing image and runtime formats helped ensure we could take an image and run it anywhere and not worry about the underlying infrastructure. This also led to the proliferation of microservices-based application architectures, where an application comprises several services running within containers to deliver the expected functionality. Most cloud-native and modern application architectures use microservices to implement the necessary functionality. When developing an application with multiple microservice dependencies, a developer must ensure the development environment is suitably set up to handle all required dependencies.\n","date":"3 Feb 2024","image":"https://cloudnativecentral.com/images/devcontainer.png","permalink":"https://cloudnativecentral.com/posts/devcontainers-for-cloud-native-application-development/","title":"Devcontainers for cloud-native application development"},{"content":"Azure Red Hat OpenShift (ARO) service provides fully managed and highly available OpenShift clusters on Azure jointly operated by Microsoft and Red Hat. There are different ways to provision an ARO cluster.\nAzure Portal Azure CLI or Azure PowerShell Azure Resource Manager (ARM) / Bicep templates Red Hat Advanced Cluster Management (RHACM) This article will explore using Bicep language to provision an ARO cluster.\nExamples in this article use Azure CLI for interacting with Azure resources and deployments.\n","date":"1 Dec 2023","image":"https://cloudnativecentral.com/images/aro.png","permalink":"https://cloudnativecentral.com/posts/using-bicep-to-provision-azure-red-hat-openshift-cluster/","title":"Using Bicep to provision Azure Red Hat OpenShift cluster"},{"content":"In an earlier article, I had written about provisioning a virtual Kubernetes cluster using kubeadm. I use this method on a laptop with limited resources. This is good to a large extent but not good enough when I want to scale my experiments and learning. This is where I started looking at creating my Kubernetes lab on Azure. I needed something that could spin fast and without manual intervention. Given my interest in the Bicep language, I wrote a Bicep template to perform this deployment.\n","date":"26 Nov 2022","image":"https://cloudnativecentral.com/images/k8saz.png","permalink":"https://cloudnativecentral.com/posts/fully-automated-kubernetes-cluster-deployment-on-azure-in-under-8-minutes/","title":"Fully Automated Kubernetes Cluster Deployment on Azure in Under 8 Minutes"},{"content":"There are many ways to install and configure Kubernetes cluster for learning and development purposes. We can use Docker Desktop, Rancher Desktop, Podman Desktop, minikube, or microk8s to quickly create a single node cluster for our development work. These are good for quick development work but not so much when we need a multi-node cluster with additional services. For such a scenario, we can use virtual machines and configure a Kubernetes cluster using kubeadm.\nThis article examines the steps necessary to set up a virtual Kubernetes cluster.\n","date":"13 Nov 2022","image":"https://cloudnativecentral.com/images/k8s.png","permalink":"https://cloudnativecentral.com/posts/installing-and-configuring-kubernetes-cluster-using-kubeadm-on-ubuntu/","title":"Installing and Configuring Kubernetes Cluster using Kubeadm on Ubuntu"}]